<!DOCTYPE html>
<html lang="en"><head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
<!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <!-- Template CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">

    <!-- Able Player Dependencies-->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <style>
          h3 {
			  font-style: italic;
		  }
		  pre {
			  font-weight: bold;
		  }
    </style>
<title>Lesson 5: Switch Statements</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12 banner-img">
<p><img src="img/banner.jpg" alt="banner"></p>
</div>
<div class="col-sm-10 offset-sm-1">
<h1>Lesson 5: Switch Statements</h1>
<h2>Switch Statements</h2>
<h3>General Structure</h3>
<p>For most switch statements, <code>gcc</code>&nbsp;implements them using a&nbsp;<code>jump table</code>. Here is an example of a jump table generated by the code in&nbsp;<a rel="noopener" target="_blank" href="https://drive.google.com/file/d/18U8QWfY0QqLoPvu1_CXtUiDIksMxsf9x/view?usp=sharing">switch.c</a>&nbsp;file:</p>
<pre class="line-numbers d2l-code"><code class="language-c">.section	.rodata
	.align 4
	.align 4
.L4:
	.long	.L3-.L4
	.long	.L8-.L4
	.long	.L5-.L4
	.long	.L6-.L4
	.long	.L6-.L4
	.long	.L7-.L4
	.text</code></pre>
<p>A jump table is written to read-only memory where constant data is stored. These lines are never executed; the CPU will skip over them. The table consists of a series of long-size (address-size) entries. Each entry is a label (or an expression involving labels) which will be replaced later by an address. This address will be where the first instruction to run for a particular case's code.</p>
<p>In the above example, both labels will be replaced with addresses and the effective address will be calculated. Each line corresponds to a case value starting at 6 and going to 11. Note that 7 is missing a case label (see the original&nbsp;<a rel="noopener" target="_blank" href="https://drive.google.com/file/d/18U8QWfY0QqLoPvu1_CXtUiDIksMxsf9x/view?usp=sharing"><code>switch.c</code>&nbsp;</a>file) and so it uses the default case's label (which is .L8). Note also that 9 and 10 share the same code so they jump to the same location (the two cases become one).</p>
<p>Under the jump table,&nbsp;<code>gcc</code>&nbsp;writes a series of labels followed by instructions. Each label plus instructions is where a case statement's body is to be run. The last label is either the default case or the next instruction after the switch statement if there is no default. In this example:</p>
<pre class="line-numbers d2l-code"><code class="language-c">.L3:
	leal	(%rdi,%rdi,2), %eax
	ret
.L5:
	leal	3(%rdi), %eax
	ret
.L6:
	leal	-3(%rdi), %eax
	ret
.L7:
	movl	$1431655766, %edx
	movl	%edi, %eax
	imull	%edx
	sarl	$31, %edi
	movl	%edx, %eax
	subl	%edi, %eax
	ret
.L8:
	movl	$0, %eax
	ret</code></pre>
<p>Usually the&nbsp;<code>break</code>&nbsp;lines in the C code would be jumps but since&nbsp;<code>doswitch</code>&nbsp;function doesn't have anything after the switch the case code just returns from the function. The return value is always in&nbsp;<code>%eax</code>&nbsp;(or&nbsp;<code>%rax</code>&nbsp;for a long value). We'll talk about functions (or procedures) next module.</p>
<div class="card card-standard">
<div class="card-body">
<p>An aside: If there is no break at the end of a case in the C code, there is no jump or return and the code just keeps going to the next case. Note this behavior is basically what you will see in C/C++ switch statement code.</p>
<p>An aside: In .L7, this is supposed to be a simple divide by 3 here. But division is costly, so&nbsp;<code>gcc</code>&nbsp;will go to great lengths to avoid it. I'm not sure how this ends up being a division by 3; I'll leave this up to students to figure it out. But do be aware that even at the lowest optimization&nbsp;<code>gcc</code>&nbsp;will generate some weird code :)</p>
</div>
</div>
<p>To run the switch statement, there is code written above the jump table at the beginning of the function:</p>
<pre class="line-numbers d2l-code"><code class="language-c">doswitch:
.LFB41:
	.cfi_startproc
	leal	-6(%rdi), %ecx
	cmpl	$5, %ecx
	ja	.L8
	movl	%ecx, %ecx
	leaq	.L4(%rip), %rdx
	movslq	(%rdx,%rcx,4), %rax
	addq	%rdx, %rax
	jmp	*%rax</code></pre>
<p>Here we need to calculate the address at which to run the value in&nbsp;<code>a</code>&nbsp;case code (<code>a</code>&nbsp;is stored in&nbsp;<code>%edi</code>). First, we offset the value so that if it is between 6 and 11, it will be between 0 and 5. Then we check to see if the value is larger than 5. If it is, then we just jump to the default case at .L8.</p>
<div class="card card-graphic">
<div class="card-body">
<div class="card-text">
<p>An aside: Note that the code treats the signed value as an unsigned so that if the value is negative it will be a very large positive number and the check will still work for a negative value.</p>
</div>
</div>
</div>
<p>If the value is valid, it now takes a combination of the offset value in&nbsp;<code>%ecx</code>&nbsp;and moves it to itself to clear out the upper part of the register so it can now use&nbsp;<code>%rcx</code>. Then it takes the address value from the jump table at the correct entry and stores this address in&nbsp;<code>%rax</code>. The next jump instruction uses this effective address to jump to the actual code that is to run.</p>
<p>Note that if the range of values is very large, the jump table will be very large too even if there are very few cases. This is because the jump table needs to have an entry for every possible value in the range. In these cases,&nbsp;<code>gcc</code>&nbsp;will resort to using a nested if-else structure with many more jumps. This can be costly performance-wise. Doing arithmetic is much faster than doing jumps. Since the jump table method does only one or two jumps compared to a series of if/else statements, then the jump table is much better on performance. So it helps to write switch statements with small ranges rather than using a large range of values. For example, if your data ranges from 1000 to 10000 always at intervals of 1000: (1000, 2000, 3000,...10000), instead of writing case 1000: ... case 2000: and so on, do a divide by 1000 and then use case 1:...case 2: and so on.</p>
</div>
<div class="col-sm-10 offset-sm-1"><footer>End of Lesson 5: Switch Statements</footer></div>
</div>
</div></body></html>