<!DOCTYPE html>
<html lang="en"><head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
<!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <!-- Template CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">

    <!-- Able Player Dependencies-->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <style>
          h3 {
			  font-style: italic;
		  }
		  pre {
			  font-weight: bold;
		  }
    </style>
<title>Lesson 4: Floating Point</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12 banner-img">
<p><img src="img/banner.jpg" alt="banner"></p>
</div>
<div class="col-sm-10 offset-sm-1">
<h1>Lesson 4: Floating Point</h1>
<div class="alert alert-secondary">NOTE: This is a summary of chapter 3.11 in the textbook.</div>
<h2>Introduction</h2>
<p>In this summary, we will cover how floating point numbers are handled in assembly code. I will not have much on floating point assembly code on the quiz, lab or exams; mainly some general facts about floating point. So this description will be brief.</p>
<p>Since the textbook is using a version of floating point assembly that is not generated by <code>gcc</code>, the instructions below have been modified from the textbook to reflect what <code>gcc</code> does generate. This way the examples match the instructions given in the tables.</p>
<h2>Floating Point</h2>
<p>Floating point numbers are handled differently than integer numbers. They are stored in a separate set of registers and use different circuitry for arithmetic, logic and other tasks.</p>
<p>Because much of the need for floating point is for processing video (compressing and de-compressing), architecture is designed to quickly do math in floating point. The system uses <b>SIMD</b> ("Single Instruction, Multiple Data") to quickly do math on multiple values in parallel.</p>
<p>This is a rapidly changing architecture. Over the years, there has been a progression of extensions and sometimes total re-writing of the instructions for floating point. The names have changed through a series of major revisions from MMX to SSE (for “streaming SIMD extensions”) and most recently AVX (for “advanced vector extensions”).</p>
<h3>Floating Point Registers</h3>
<p>Floating point numbers are stored in a separate set of registers from the integer registers we have been working with. Again, like the integer registers, over the years, the registers have grown in size but still retain the older naming conventions for smaller portions of the registers. However, the names are more consistent than in integer registers. There are three sizes:</p>
<ol>
<li><code>mm*</code> - 64 bit regs</li>
<li><code>xmm*</code> - 128 bit regs</li>
<li><code>ymm*</code> - 256 bit regs</li>
</ol>
<p>The asterisk (*) can be filled in with a number from 0 to 15 to get the full name of a register. Examples are <code>xmm0</code>, <code>mm2</code>, <code>ymm10</code> and so on.</p>
<p><!-- [[ diagram of registers ]] --></p>
<p>Unlike the integer registers, each register can hold multiple values for parallel processing. For example, you can load four doubles in <code>%ymm0</code> and then add these to four other doubles in <code>%ymm1</code> and store it back in <code>%ymm0</code> in one instruction cycle instead of four instruction cycles.</p>
<p><!-- [[ good place for a diagram of a reg holding multi-values ]] --></p>
<p>This doesn't mean however that you need to use the SIMD features. The examples we will be showing will be simple <code>scalar</code> (one value) instructions. But if you are interested, the textbook's website has an aside on how to work with SIMD instructions.</p>
<p>The x86-64 architecture can use SSE2 and the later AVX2 instructions. The textbook is based on AVX2 instructions but this is NOT typically what <code>gcc</code> uses when generating floating point instructions. So the instructions on this page have been modified to SSE2 instructions instead. Basically the difference comes down to getting rid of an extra 'v' in front of the instruction names and having one less operand. If you want to have <code>gcc</code> generate the AVX2 instructions (there's no need to in this class though), you can run <code>gcc</code> with the <code>-mavx2</code> option.</p>
<h3>xmm Registers</h3>
<p>There are 16 registers used for both single (float) and double precision: <code>xmm0-xmm15</code>. Figure 3.45 in section 3.11 shows the configuration of these registers.</p>
<p>These are the lower 16 bytes of a much larger set of registers (ymm*). For floats, only the low-order 32 bits (4 bytes) are used if storing one value. For doubles, the low-order 64 bits (8 bytes) are used. Note that you can store 4 floats or 2 doubles in this register. That's by design as they are used to do math of multiple values in the same register. There are 'pack' instructions for 'packing' more than one value in one register; these instructions end in a 'p'. But we will concentrate on the scalar versions which end in an 's'.</p>
<p>Note that, like integer registers, there are several registers used for passing arguments. There are 8 of them so technically you can have up to 8 parameters in a function call before the arguments get pushed onto the stack. Also, when it says '1st fp argument' this is by counting <b>only</b> floating point arguments. For example, if you have parameters in this order:</p>
<pre class="line-numbers d2l-code"><code class="language-c">(float a, int b, float c) </code></pre>
<p><code>'a'</code> will be in <code>%xmm0</code>, <code>'b'</code> will be in <code>%edi</code>, and <code>'c'</code> will be in <code>%xmm1</code>. Also note that all registers are caller saved in that it's up to the caller procedure to save information in registers it is using before a call.</p>
<h3>Moving Data</h3>
<p>Figure 3.46 has move commands for both registers and memory. The same memory-to-memory restriction applies to floating point. In SSE2, the instructions are <code>movss</code> for single precision (float) and <code>movsd</code> for double precision (double).</p>
<h3>Moving Floating Point to Integer</h3>
<p>When typecasting in C from a floating point to an integer, <code>gcc</code> will use the <code>cvttss2si</code> instruction for single precision and <code>cvttsd2si</code> for double precision. Note that the first operand is the source and needs to be either a memory location or a floating point register; the second operand needs to be an integer register only. Note that these instructions will convert from floating point format (IEEE 754) to integer format (2's complement) and also truncate the fractional part of the original number (this is the same as 'round toward zero').</p>
<h3>Moving Integer To Floating Point</h3>
<p>When typecasting in C from an integer to a floating point, <code>gcc</code> will use the <code>cvtsi2ss</code> instruction for single precision and <code>cvtsi2sd</code> for double precision. Note that the first operand is the source and needs to be either a memory location or an integer register; the second operand needs to be a floating point register only. Again, this does the necessary conversion of formats from integer to floating point before copying into the register.</p>
<h3>Arithmetic Operations</h3>
<p>Below is a list of the more commonly used arithmetic operations for floating point.</p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr>
<th>Single</th>
<th>Double</th>
<th>Effect</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="white-space: nowrap;">addss S, D</td>
<td style="white-space: nowrap;">addsd S, D</td>
<td style="white-space: nowrap;">S + D -&gt; D</td>
<td>adds S to D and puts result in D.</td>
</tr>
<tr>
<td style="white-space: nowrap;">subss S, D</td>
<td style="white-space: nowrap;">subsd S, D</td>
<td style="white-space: nowrap;">D - S -&gt; D</td>
<td>subtracts S from D and puts result in D.</td>
</tr>
<tr>
<td style="white-space: nowrap;">mulss S, D</td>
<td style="white-space: nowrap;">mulsd S, D</td>
<td style="white-space: nowrap;">S x D -&gt; D</td>
<td>multiplies D and S and puts result in D.</td>
</tr>
<tr>
<td style="white-space: nowrap;">divss S, D</td>
<td style="white-space: nowrap;">divsd S, D</td>
<td style="white-space: nowrap;">D / S -&gt; D</td>
<td>divides D by S and puts result in D.</td>
</tr>
<tr>
<td style="white-space: nowrap;">maxss S, D</td>
<td style="white-space: nowrap;">maxsd S, D</td>
<td style="white-space: nowrap;">max(S,D) -&gt; D</td>
<td>compares S and D and writes the larger to D</td>
</tr>
<tr>
<td style="white-space: nowrap;">minss S, D</td>
<td style="white-space: nowrap;">minsd S, D</td>
<td style="white-space: nowrap;">min(S,D) -&gt; D</td>
<td>compares S and D and writes the smaller to D</td>
</tr>
<tr>
<td style="white-space: nowrap;">sqrtss S</td>
<td style="white-space: nowrap;">sqrtsd S</td>
<td style="white-space: nowrap;">square root of S -&gt; S</td>
<td>takes the square root of S and puts the result into S. Note that it takes only one operand.</td>
</tr>
</tbody>
</table>
</div>
<h3>Floating Point Constants</h3>
<p>Most floating point instructions can't have an immediate value. So working with constants means they need to be stored elsewhere in memory. Then the memory address is used to retrieve the constant value. Usually constant values are stored in a read-only part of the assembly code similar to jump tables. The constants are stored in .long values in such a way that their bit pattern will match the correct IEEE 754 floating point format for that value. So they tend to look like extremely long numbers.</p>
<h3>Bit-Wise Logical Operations</h3>
<p>There are very few bit-wise operations that are done on floating point. The IEEE 754 format just doesn't lend itself to doing bit manipulation. But there are two bit-wise logical operations that sometimes are performed on floating point: <code>xorps</code> (<code>xorpd</code> for doubles) for doing exclusive or. This works on the whole register and can be used to quickly clear out a register by XORing the register with itself. Another one used is <code>andpd</code> for doing bitwise checks using a mask.</p>
<h3>Comparisons in Floating Point</h3>
<p>Floating Point instructions use the same condition flags as integer instructions. There are two floating point specific instructions for comparing floating point numbers: <code>ucomiss</code> for single precision and <code>ucomisd</code> for double precision. They basically do the same as the <code>cmp</code> instruction. They take two operands and subtract the first from the second. Then the condition flags are set depending on the results.</p>
<p>There is one other conditional flag that is handy for checking if a floating point value has become a NaN value. This is the PF or parity flag. This is set to 1 when the result of a floating point instruction is a NaN value.</p>
<h2>Example Code</h2>
<pre class="line-numbers d2l-code"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

double afunct(double ad, int count, double bd)
{
	double sd = ad*bd;
	double res = sd*count;
	return res;
}

double comparefp(double ad, int count, double bd)
{
	if(ad &lt; bd)
	{
		return ad;
	}
	return bd;
	
}

void inputValues(double* ad, double* bd)
{
	printf("Enter two floats: ");
	scanf("%lf",ad);
	scanf("%lf",bd);
}

int main()
{
	double ad = 0.0;
	double bd = 0.0;
	int count = 8;
	
	inputValues(&amp;ad, &amp;bd);
	
	double res = afunct(ad, count, bd);
	printf("product is %6.4lf\n", res);
	
   return 0;	
}</code></pre>
</div>
<div class="col-sm-10 offset-sm-1"><footer>End of Lesson 4: Floating Point</footer></div>
</div>
</div></body></html>