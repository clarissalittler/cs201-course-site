<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <style>
          h3 { font-style: italic; }
          pre { font-weight: bold; }
    </style>
<title>Lesson 1: What a Kernel Does</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12 banner-img"><p><img src="img/banner.jpg" alt="banner"></p></div>
<div class="col-sm-10 offset-sm-1">
<h1>Lesson 1: What a Kernel Does</h1>

<h2>Introduction</h2>
<p>Every time you have called <code>fork()</code> to create a process, used <code>malloc()</code> to allocate memory, opened a file with <code>open()</code>, or connected to a remote server with a socket, you were asking the operating system's <b>kernel</b> to do work on your behalf. The kernel is the core of the operating system. It is the one program that is always running, from the moment the machine boots until it shuts down. Everything else &mdash; your shell, your text editor, your web browser, every program you have written in this course &mdash; runs on top of the kernel and depends on it.</p>
<p>In this lesson, we will look at what the kernel actually does, how it separates itself from user programs, and how your programs communicate with it through system calls.</p>

<h2>What Is a Kernel?</h2>
<p>The kernel is the lowest-level software component that runs directly on the hardware. It has complete access to all of the machine's resources: every byte of memory, every CPU instruction, every hardware device. Its job is to manage those resources and provide a safe, consistent interface for user programs to use them.</p>
<p>Think of the kernel as a referee and a resource manager. It decides which process gets to run on the CPU and for how long. It keeps each process's memory separate so one buggy program cannot corrupt another. It translates your program's request to "read a file" into the specific sequence of disk operations needed to retrieve the data. Without a kernel, every program would need to include its own code for talking to hardware, and there would be nothing to prevent one program from interfering with another.</p>

<h3>Kernel Responsibilities</h3>
<p>The kernel handles several major categories of work:</p>
<ul>
<li><b>Process management:</b> Creating new processes (<code>fork()</code>), loading programs into them (<code>exec()</code>), scheduling which process runs on which CPU core, and cleaning up when processes terminate. The kernel maintains a process table that tracks every running process, its state (running, ready, sleeping, zombie), its register values, and its memory mappings.</li>
<li><b>Memory management:</b> Implementing virtual memory so each process thinks it has its own private address space. The kernel maintains page tables that map virtual addresses to physical addresses, handles page faults when a process accesses memory that is not currently in RAM, and decides which pages to evict to disk when physical memory is full. You studied this in the previous module on memory hierarchy.</li>
<li><b>Device management:</b> Providing device drivers that know how to communicate with specific hardware: disk controllers, network cards, USB devices, GPUs, keyboards, and so on. The kernel abstracts these into a uniform interface so your program can use <code>read()</code> and <code>write()</code> without knowing the details of the underlying hardware.</li>
<li><b>File systems:</b> Organizing data on disk into files and directories. The kernel implements file system formats (ext4, XFS, NTFS, etc.) and provides the familiar interface of <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close()</code>. It also handles permissions, so one user's files are protected from another user.</li>
<li><b>Networking:</b> Implementing the entire TCP/IP networking stack. When you create a socket and call <code>connect()</code>, the kernel handles the TCP three-way handshake, manages packet buffering, implements congestion control, and routes data between your program and the network hardware.</li>
<li><b>Inter-process communication (IPC):</b> Providing mechanisms for processes to communicate: pipes, signals, shared memory, message queues, and sockets (including Unix domain sockets for local communication).</li>
</ul>

<h2>User Mode vs. Kernel Mode</h2>
<p>A critical question arises: if the kernel has complete control over the hardware, how do we prevent a buggy or malicious user program from taking over the machine? The answer is built into the CPU hardware itself.</p>
<p>Modern CPUs have at least two <b>privilege levels</b> (also called <b>protection rings</b>). On x86 processors, there are four rings numbered 0 through 3, but in practice only two are used:</p>
<ul>
<li><b>Ring 0 (kernel mode / supervisor mode):</b> The kernel runs here. Code running in ring 0 can execute any CPU instruction, access any memory address, and interact directly with hardware devices. This is the most privileged level.</li>
<li><b>Ring 3 (user mode):</b> All user programs run here. Code running in ring 3 is restricted. It cannot execute privileged instructions (like <code>hlt</code> to halt the CPU or instructions that modify page tables), it cannot access memory belonging to the kernel or other processes, and it cannot directly communicate with hardware.</li>
</ul>
<p>The CPU enforces these restrictions in hardware. If a user-mode program tries to execute a privileged instruction, the CPU generates a <b>general protection fault</b> (GPF, interrupt 13), which the kernel catches and handles &mdash; typically by killing the offending process. This is related to, but distinct from, the <b>page fault</b> (interrupt 14) that occurs when a program accesses invalid memory. In both cases, the kernel typically delivers a <code>SIGSEGV</code> signal ("segmentation fault") to the process, but the underlying hardware exceptions are different.</p>
<p>This hardware-enforced separation is fundamental to system security and stability. No matter how buggy a user program is, it cannot crash the kernel or access another process's memory, because the CPU physically will not allow it. The only way for a user program to request kernel services is through a carefully controlled gateway: the <b>system call</b>.</p>

<h2>System Calls: The User-Kernel Interface</h2>
<p>A <b>system call</b> (or <b>syscall</b>) is the mechanism by which a user program requests a service from the kernel. You have been using system calls throughout this course &mdash; <code>fork()</code>, <code>exec()</code>, <code>wait()</code>, <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, <code>socket()</code>, <code>mmap()</code>, <code>kill()</code>, and many others are all system calls (or thin wrappers around system calls provided by the C library).</p>

<h3>How a System Call Works</h3>
<p>Let us trace what happens when your C program calls <code>write(fd, buf, n)</code>:</p>
<ol>
<li><b>The C library wrapper:</b> The <code>write()</code> function in your program is actually a wrapper function provided by the C library (glibc on Linux). This wrapper sets up the arguments according to the system call convention and then executes a special CPU instruction.</li>
<li><b>The syscall instruction:</b> On modern x86-64 Linux, the wrapper executes the <code>syscall</code> instruction. (On older 32-bit x86 systems, it was <code>int 0x80</code>, a software interrupt.) Before executing this instruction, the wrapper places the <b>system call number</b> in the <code>%rax</code> register. For <code>write()</code>, the syscall number is 1. The arguments go in registers <code>%rdi</code>, <code>%rsi</code>, and <code>%rdx</code> &mdash; the file descriptor, buffer pointer, and byte count, respectively.</li>
<li><b>CPU mode switch:</b> The <code>syscall</code> instruction causes the CPU to switch from ring 3 (user mode) to ring 0 (kernel mode). The CPU saves the user program's instruction pointer and stack pointer, then jumps to a predefined <b>system call entry point</b> in the kernel.</li>
<li><b>Syscall dispatch:</b> The kernel's entry point code looks at the value in <code>%rax</code> (the syscall number) and uses it as an index into the <b>system call table</b> &mdash; an array of function pointers, one for each system call. For syscall number 1, it finds the pointer to the kernel's internal <code>sys_write()</code> function.</li>
<li><b>Kernel handles the request:</b> The kernel's <code>sys_write()</code> function validates the arguments (is the file descriptor valid? does the buffer pointer point to memory the process is allowed to read? etc.), then performs the actual I/O operation &mdash; copying data from the user's buffer into a kernel buffer and ultimately to the device.</li>
<li><b>Return to user mode:</b> When the kernel function completes, it places the return value in <code>%rax</code> (the number of bytes written, or -1 on error), and executes the <code>sysret</code> instruction. This switches the CPU back to ring 3 and jumps back to the instruction after the <code>syscall</code> in the user program.</li>
</ol>
<p>This entire sequence &mdash; switching to kernel mode, dispatching to the right handler, doing the work, and returning &mdash; happens every time you make a system call. It is extremely fast (a few hundred nanoseconds on modern hardware), but it is not free. The mode switch, the saving and restoring of registers, and the various security checks all take time. This overhead becomes important when we discuss kernel architecture in the following lessons.</p>

<h3>The System Call Table</h3>
<p>The system call table is simply an array where each index corresponds to a syscall number, and each entry is a function pointer to the kernel function that handles that call. On Linux x86-64, a few examples:</p>
<div class="table-responsive">
<table class="table table-bordered">
<thead>
<tr><th>Syscall Number (%rax)</th><th>Name</th><th>Kernel Function</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>read</td><td>sys_read</td></tr>
<tr><td>1</td><td>write</td><td>sys_write</td></tr>
<tr><td>2</td><td>open</td><td>sys_open</td></tr>
<tr><td>3</td><td>close</td><td>sys_close</td></tr>
<tr><td>39</td><td>getpid</td><td>sys_getpid</td></tr>
<tr><td>57</td><td>fork</td><td>sys_fork</td></tr>
<tr><td>59</td><td>execve</td><td>sys_execve</td></tr>
<tr><td>60</td><td>exit</td><td>sys_exit</td></tr>
<tr><td>62</td><td>kill</td><td>sys_kill</td></tr>
</tbody>
</table>
</div>
<p>Linux currently has over 300 system calls. You can see them all listed in the kernel source file <code>arch/x86/entry/syscalls/syscall_64.tbl</code>, or by looking at the header <code>/usr/include/asm/unistd_64.h</code> on your Linux system.</p>

<h2>Context Switches</h2>
<p>A <b>context switch</b> occurs when the kernel stops running one process and starts running another. This is how the kernel implements multitasking &mdash; giving the illusion that many processes are running simultaneously on a machine with a limited number of CPU cores.</p>
<p>During a context switch, the kernel must:</p>
<ol>
<li><b>Save the state of the current process:</b> All general-purpose registers, the instruction pointer, the stack pointer, the floating-point registers, and the status flags are saved into a data structure called the <b>process control block</b> (PCB) or <b>task struct</b> (the name used in Linux).</li>
<li><b>Switch the memory mapping:</b> Load the page table base register (CR3 on x86) with the new process's page table pointer, so virtual addresses now map to the new process's physical memory.</li>
<li><b>Restore the state of the new process:</b> Load the new process's saved register values, instruction pointer, and stack pointer from its task struct.</li>
<li><b>Resume execution:</b> The CPU continues executing from wherever the new process left off.</li>
</ol>
<p>Context switches are triggered by several events: a timer interrupt (the kernel preempts a process that has used up its time slice), a system call that blocks (such as <code>read()</code> waiting for disk I/O), or an explicit yield by the process. The kernel's <b>scheduler</b> decides which process to run next. On Linux, the default scheduler was the <b>Completely Fair Scheduler (CFS)</b> for many years (through kernel 6.5). Starting with Linux 6.6 (2023), CFS was replaced by the <b>EEVDF (Earliest Eligible Virtual Deadline First)</b> scheduler. Both share the same basic principle: give each process a fair share of CPU time.</p>
<p>Context switches are expensive relative to normal instruction execution. A typical context switch on modern x86 hardware takes on the order of 1-10 microseconds, depending on how much state needs to be saved and whether the TLB (translation lookaside buffer) must be flushed. This cost is one reason why creating too many processes or threads can degrade performance &mdash; the system spends too much time switching between them and too little time doing actual work.</p>

<h2>Connecting It All Together</h2>
<p>Let us revisit some of the things you have done in this course and see them through the lens of kernel services:</p>
<ul>
<li>When you called <code>fork()</code>, you asked the kernel to create a new entry in the process table, copy the parent's page tables (using copy-on-write optimization), and set up a new task struct.</li>
<li>When you called <code>exec()</code>, you asked the kernel to replace the current process's memory image with a new program loaded from disk, setting up new code, data, and stack segments.</li>
<li>When you called <code>wait()</code>, you asked the kernel to put your process to sleep until one of its children changed state, and to give you the child's exit status.</li>
<li>When you registered a signal handler with <code>sigaction()</code>, you asked the kernel to record a function pointer and, when the specified signal arrives, to interrupt the process and redirect execution to your handler.</li>
<li>When you opened a file with <code>open()</code>, the kernel allocated a file descriptor, looked up the file in the file system, and created internal data structures to track your position in the file.</li>
<li>When you created a socket and called <code>connect()</code>, the kernel managed the entire TCP handshake, set up buffer space for sending and receiving data, and handled all the low-level packet formatting and network routing.</li>
<li>When you called <code>malloc()</code>, the C library either carved memory from a pre-allocated pool or called the <code>brk()</code>/<code>mmap()</code> system call to ask the kernel for more virtual memory pages.</li>
</ul>
<p>Every one of these operations required crossing the user-kernel boundary. The kernel was doing the real work behind the scenes all along. In the next three lessons, we will examine how that kernel itself can be organized, and the significant consequences that different organizational choices have for performance, reliability, and security.</p>

<div class="alert alert-info">
<b>Practice Problem:</b> When you run a simple C program that prints "Hello, world!" using <code>printf()</code>, at least two system calls occur: <code>write()</code> to output the string and <code>exit_group()</code> to terminate the process. In reality, many more occur during program startup and shutdown. On a Linux system, you can use the <code>strace</code> command to see every system call a program makes. Try running <code>strace ./hello</code> on one of your programs and count how many system calls occur for even the simplest program. What do you observe?
</div>

<div class="alert alert-info">
<b>Practice Problem:</b> Consider the following scenario: Process A is running, and it calls <code>read(fd, buf, 4096)</code> to read from a file on disk. The data is not in the kernel's page cache, so the kernel must wait for the disk. Describe, step by step, what happens from the moment <code>read()</code> is called until Process A has its data. Your answer should include: the system call entry, the context switch away from Process A, the disk interrupt, and the context switch back to Process A.
</div>

<footer>End of Lesson 1: What a Kernel Does</footer></div>
</div></div></body></html>