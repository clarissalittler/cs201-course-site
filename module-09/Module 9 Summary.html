<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <style>
          h3 { font-style: italic; }
          pre { font-weight: bold; }
    </style>
<title>Module 9 Summary: Optimization</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12 banner-img"><p><img src="img/banner.jpg" alt="banner"></p></div>
<div class="col-sm-10 offset-sm-1">
<h1>Module 9 Summary: Optimization</h1>

<h2>Key Takeaways</h2>

<h3>Correctness First, Performance Second</h3>
<p>The single most important lesson from this module is that correctness must always come before performance. A fast program that produces wrong results is useless. Optimization should only be pursued after a program is working correctly, and only when measurement shows that the performance improvement is meaningful to the end user. Not every program needs to be optimized, and a programmer should always weigh the cost of reduced readability and increased complexity against the benefit of faster execution.</p>

<h3>Let the Compiler Help</h3>
<p>Modern compilers like gcc are remarkably capable optimizers. By using optimization flags such as <b>-O1</b>, <b>-O2</b>, or <b>-O3</b>, the compiler can automatically apply many transformations that would be tedious and error-prone to do by hand. However, the compiler has limitations. It must produce code that behaves identically to the original in all cases, so it cannot make optimizations that depend on assumptions about data values, pointer aliasing, or side effects. Writing compiler-friendly code&mdash;avoiding unnecessary pointer aliasing, reducing function call overhead, and keeping expressions simple&mdash;helps the compiler do its job better.</p>

<h3>Measure Before You Optimize</h3>
<p>Programmers are notoriously bad at guessing where the performance bottlenecks in their programs are. Profiling tools like <b>gprof</b> take the guesswork out of optimization by showing exactly which functions and loops consume the most time. Always profile first and focus your optimization efforts on the hot spots that the profiler identifies. Optimizing code that accounts for 1% of execution time is a waste of effort no matter how clever the optimization is.</p>

<h3>Code-Level Optimization Techniques</h3>
<p>Several programmer-driven techniques can improve performance beyond what the compiler achieves on its own:</p>
<ul>
<li><strong>Reducing procedure calls:</strong> Moving function calls out of loops when the result does not change between iterations.</li>
<li><strong>Eliminating unnecessary memory references:</strong> Accumulating results in local variables (which the compiler can keep in registers) rather than writing repeatedly to memory through pointers.</li>
<li><strong>Loop unrolling:</strong> Performing multiple iterations of work in a single pass through the loop body, reducing loop overhead and enabling instruction-level parallelism.</li>
<li><strong>Exploiting instruction-level parallelism:</strong> Restructuring computations so that the processor's multiple functional units can work simultaneously.</li>
</ul>

<h3>Cache-Aware Programming Is a Practical Skill</h3>
<p>Perhaps the most impactful optimization technique covered in this module is writing cache-friendly code. Because accessing data in main memory can be 100 times slower than accessing data in L1 cache, the way a program traverses its data structures can have an enormous effect on performance. The key principles are straightforward:</p>
<ul>
<li><strong>Favor sequential access patterns</strong> that exploit spatial locality. In C, this means traversing 2D arrays in row-major order (varying the column index in the inner loop) rather than column-major order.</li>
<li><strong>Use loop tiling (blocking)</strong> to keep working data within the cache for matrix and grid computations, rather than sweeping across entire rows or columns that evict useful data.</li>
<li><strong>Choose data layouts carefully.</strong> When a computation only accesses a subset of fields in a structure, a Structure of Arrays layout can provide better cache utilization than an Array of Structures layout.</li>
<li><strong>Minimize unnecessary memory accesses</strong> by accumulating intermediate results in local variables.</li>
<li><strong>Keep data naturally aligned</strong> so that individual values do not straddle cache line boundaries.</li>
</ul>
<p>These are not exotic techniques reserved for systems programmers. Any programmer who works with large data sets or performance-sensitive code will benefit from understanding how the memory hierarchy affects program speed.</p>

<h2>Looking Ahead</h2>
<p>The optimization techniques and cache-awareness principles from this module connect directly to topics in parallel programming and systems design. Understanding how data moves through the memory hierarchy is foundational knowledge that will serve you throughout your career in computer science, whether you are writing embedded systems code, building web servers, or designing data processing pipelines.</p>

<footer>End of Module 9 Summary: Optimization</footer></div>
</div></div></body></html>
