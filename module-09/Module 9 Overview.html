<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <title>Module 9: Virtual Memory, Linking, and Dynamic Memory</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12">
<div class="intersect-wrapper bg-img-wrapper" id="bg-img-wrapper-3">
<p><img src="img/banner.jpg" alt=""></p>
<div class="row"><div class="intersect-content text-center offset-md-1 col-md-10">
<div class="offset-md-1  col-md-10"><h1>Module 9: Virtual Memory, Linking, and Dynamic Memory</h1></div></div></div></div></div>
<div class="offset-md-2 col-md-8">

<p>In Module 9, we explore how the operating system manages memory and how programs are loaded and run. We begin with virtual memory &mdash; the mechanism that gives each process its own private address space while sharing a single pool of physical memory. With that foundation in place, we examine linking: how object files are combined into executables, how shared libraries work, and why dynamic linking depends on virtual memory concepts like position-independent code and memory-mapped files. Finally, we study dynamic memory allocation &mdash; how <b>malloc</b> and <b>free</b> manage the heap, what happens under the hood, and how to avoid the common pitfalls that plague C programs. The module concludes with garbage collection, the automatic memory management approach used by languages like Java, Python, and Go.</p>
<p>These topics build on each other. Understanding virtual memory explains the address space within which programs are loaded and within which malloc operates. Understanding linking explains how code and data actually get placed into that address space. And understanding malloc explains how the programmer manages the heap region of that space at runtime.</p>

<h2>Learning Objectives</h2>
<p>At the end of this learning module, you will be able to:</p>
<ol>
<li>Explain how virtual memory works, including virtual and physical addresses, page tables, the TLB, and page faults.</li>
<li>Describe the purpose of demand paging and swapping, and explain how the operating system manages physical memory.</li>
<li>Explain the difference between static and dynamic linking, including the roles of the linker, symbol resolution, and relocation.</li>
<li>Describe how shared libraries work, including position-independent code (PIC), the PLT, and the GOT.</li>
<li>Use the malloc/free API correctly in C programs to allocate and deallocate heap memory.</li>
<li>Explain how malloc manages the heap internally, including free lists, block structure, and allocation strategies.</li>
<li>Identify and avoid common dynamic memory errors such as memory leaks, dangling pointers, double frees, and buffer overflows.</li>
<li>Use Valgrind to detect memory errors including leaks, invalid reads and writes, use of uninitialized memory, and double frees.</li>
<li>Explain the basic concepts of garbage collection, including mark-and-sweep, reference counting, and generational collection, and contrast automatic memory management with C's manual approach.</li>
</ol>

<h2>Learning Activities</h2>
<p>You are expected to do the following tasks in order to achieve the above objectives:</p>
<ol>
<li>Complete the reading listed below.</li>
<li>Read Lessons 1 through 5 and complete the embedded practice problems.</li>
<li>Compile and experiment with the provided C code examples. Pay special attention to the malloc/free examples.</li>
<li>Run your C programs under Valgrind with <code>--leak-check=full</code> to check for memory errors. Practice reading Valgrind output and fixing each reported issue.</li>
<li>Take Quiz 9.</li>
<li>Review additional resources on the Module 9 Summary page.</li>
</ol>

<h2>Reading</h2>
<ul>
<li>Bryant &amp; O'Hallaron: Chapter 7 (Linking)</li>
<li>Bryant &amp; O'Hallaron: Chapter 9 (Virtual Memory)</li>
</ul>
<p>If you have questions, you can post them in the course lobby or send your instructor an email.</p>

</div></div>
<div class="col-12"><footer><p>End of Module 9 Overview</p></footer></div></div>
</body></html>
