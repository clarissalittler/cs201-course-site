<!DOCTYPE html>
<html lang="en"><head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
<!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <!-- Template CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">

    <!-- Able Player Dependencies-->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <style>
          h3 {
			  font-style: italic;
		  }
		  pre {
			  font-weight: bold;
		  }
    </style>
<title>Lesson 3: Signed Integer Encoding</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12 banner-img">
<p><img src="img/banner.jpg" alt="banner"></p>
</div>
<div class="col-sm-10 offset-sm-1">
<h1>Lesson 3: Getting Assembly and Machine Code</h1>
<h2>Getting Assembly and Machine Code</h2>
<h3>gcc&nbsp;-S Option</h3>
<p>You can get a printout of the assembly code that is generated by the&nbsp;<code>gcc</code> compiler in several ways. One way is to use the option&nbsp;<code>-S</code> which will stop after the compilation step where the assembly code is generated and then write the results to a file with the ending <code>.s</code>.</p>
<p>For example, make a file called&nbsp;<code>mstore.c</code> and copy this code into it:</p>
<pre class="line-numbers d2l-code"><code class="language-c">long mult2(long, long);

void multstore(long x, long y, long *dest) {
  long t = mult2(x, y);
  *dest = t;
}</code></pre>
<p></p>
<p>This is just a function, so it won't compile to a runnable program. However, you can stop the compiler process after the compiler step by using this command:</p>
<code>  gcc -Og -S mstore.c</code>
<p></p>
<p>The <code>-Og</code>&nbsp;(capital O g) option is an optimization level. Using&nbsp;<code>g</code> sets this to minimally optimized code designed to run inside a debugger. This makes the generated assembly code more in line with the original code.&nbsp;</p>
<div class="card card-standard">
<div class="card-body">
<p>An aside: The&nbsp;<code>-O</code> option follow by a number (or in some cases a letter) changes how much optimization the compiler does. At low numbers (0, maybe 1), the optimization is minimal, making the underlying assembly code reflect the written C code better. At high numbers (1, 2, 3), optimization techniques tend to make the assembly code very hard to follow. This is why, in this class, we will use either -Og or -O0 levels when examining assembly code.</p>
</div>
</div>
<p>After doing the above command, in the current directory you should see a&nbsp;<code>mstore.s</code>&nbsp;file. open this up in an editor. The&nbsp;<code>gcc</code>&nbsp;generated file on my Linux laptop looks like this:</p>
<pre class="line-numbers d2l-code"><code class="language-c">.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
	.section	.note.GNU-stack,"",@progbits </code></pre>
<pre></pre>
<p>The lines preceded by periods (<code>.</code>) are information for the linker to add its own code to. You can ignore these for now. The <code>multstore</code> line is a&nbsp;<strong>label</strong>. These are placeholders for memory addresses that the linker will provide later. The more interesting lines are the ones without a period. These are assembly code instructions. For the rest of the next two or three weeks, we will be looking at these instructions, but for now, just note how to generate these from code.&nbsp;</p>
<p>If you use the&nbsp;<code>-c</code>&nbsp;option,&nbsp;<strong>gcc</strong> will call an assembler that will take this assembly code and generate the machine code for this file. This is then stored in binary files with an ending <code>.o</code> for 'object files.' Unfortunately, you can't open these in a text editor, but there are several 'hex editors' you can find to look at the contents of these files.&nbsp;</p>
<h3>Using&nbsp;<code>objdump</code></h3>
<p>Another way to get both assembly code along with its machine code is using the available disassembler in Linux called <code>objdump</code>. This will generate to the terminal a 'disassembly' of an object file or even an executable (it doesn't work directly on source code files though). Disassembly is taking machine-level code and making a good guess as to what the original assembly code is. This is a 'guess' because some information, such as info for the linker, is lost in the executable, so you may not get the exact same assembly code that generated the file. Also, the style of assembly code written may be slightly different from <strong>gcc</strong>'s assembly code. For example,&nbsp;<code>objdump</code>&nbsp;tends not to use the size indicators on the ends of the instructions.</p>
<p>Start by creating the object file to look at.</p>
<code>  gcc -Og -c mstore.c</code>
<p></p>
<p>Then run <code>objdump</code>&nbsp;with a -d option to get the disassembly. I am redirecting the output to a text file so I can open it and examine it.</p>
<code>  objdump -d mstore.o &gt; mstore.txt</code>
<p></p>
<p>Open up mstore.txt in an editor (or use the 'cat' command to print it) you can see the results. On my system, I get:</p>
<pre class="line-numbers d2l-code"><code class="language-c">mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;multstore&gt;:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 &lt;multstore+0x9&gt;
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq    &lt;/multstore+0x9&gt;&lt;/multstore&gt;</code></pre>
<p></p>
<p>The leftmost column is an offset into the file where the following bytes are located. The following bytes in each line are the machine code. Everything here is displayed in hexadecimal numbers. The rightmost columns are the objdump's best guess as to what the assembly code would be for each machine level code.</p>
<p>The above uses the object code that still has some of the labels left in them. If we were doing this with an executable, these would be the actual memory address.&nbsp;</p>
<p>Copy the following into a main.c file:</p>
<pre class="line-numbers d2l-code"><code class="language-c">#include &lt;stdio.h&gt;
	
void multstore(long, long, long *);

int main() {
   long d;
   multstore(2, 3, &amp;amp;d);
   printf("2 * 3 --&amp;gt; %ld\n", d);
   return 0;
}

long mult2(long a, long b) {
   long s = a * b;
   return s;
}
 &lt;/stdio.h&gt;</code></pre>
<p></p>
<p>Now use the command:</p>
<code>   gcc -Og main.c mstore.c -o prog </code>
<p></p>
<p>This should make an executable called <code>prog</code>. Now use <code>objdump</code> and put the output in a file called 'prog.txt':</p>
<code>   objdump -d prog &gt; prog.txt</code>
<p></p>
<p>The printout is much longer than the object file printout. This is because the assembly and linking stages add a lot of extra assembly code that's needed to run the code as a program. Notice it's broken up into sections that you can search on. Each one represents a function; some of these are imported from the standard C library. You can search for <code>main</code>, <code>mult2</code>, and <code>multstore</code> sections.</p>
<p>The gdb debugger is another way to see assembly code. We'll discuss this at another time.</p>
<h3>Using&nbsp;<code>gdb disassemble</code>&nbsp;Command</h3>
<p>It is also possible to look at your program's assembly code by using the&nbsp;<code>gdb</code>&nbsp;debugger by using the&nbsp;<code>disassemble</code> command. For more information, see this&nbsp;<a href="mohito.io: gdb assembly language debugging 101">tutorial on using gdb</a> with assembly code.</p>
</div>
<div class="col-sm-10 offset-sm-1"><footer>End of Lesson 3: Getting Assembly and Machine Code</footer></div>
</div>
</div></body></html>