<!DOCTYPE html>
<html lang="en"><head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
<!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/bootstrap-4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/thirdpartylib/fontawesome-free-5.9.0-web/css/all.min.css">
    <!-- Template CSS -->
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/styles.min.css">
    <link rel="stylesheet" href="/shared/IDEAS-developments/template-columbia/_assets/css/custom.css">

    <!-- Able Player Dependencies-->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="/shared/videos/ableplayer/thirdparty/js.cookie.js"></script>
    <link rel="stylesheet" href="/shared/videos/ableplayer/build/ableplayer.min.css" type="text/css">
    <script src="/shared/videos/ableplayer/build/ableplayer.min.js"></script>
    <script src="https://player.vimeo.com/api/player.js"></script>
    <script src="https://cdnapisec.kaltura.com/p/823192/sp/82319200/embedIframeJs/uiconf_id/46847663/partner_id/823192"></script>
    <script src="/shared/videos/ableplayer/ablefier.js"></script>
    <style>
          h3 {
			  font-style: italic;
		  }
		  pre {
			  font-weight: bold;
		  }
    </style>
<title>Lesson 6: How to Measure Performance</title>
</head><body><div class="container-fluid">
<div class="row">
<div class="col-12 banner-img">
<p><img src="img/banner.jpg" alt="banner"></p>
</div>
<div class="col-sm-10 offset-sm-1">
<h1>Lesson 6: How to Measure Performance</h1>
<h2>How to Measure Performance</h2>
<p>In order to understand how well our optimization is working, we need to be able to measure how fast our programs are running. The textbook defines something called cycles per element (CPE) which it then uses for its optimization example. This is fine but not necessarily available outside of the book's code.</p>
<p>Most optimization tools in the industry (benchmarks, profilers, etc) use <b>CPU time</b>. CPU time is the amount of time in seconds a CPU was processing this particular program (as opposed to other programs that were also using the CPU). This is more accurate than straight clock time as it doesn't measure the times that the program was inactive.</p>

<h3>The time Command</h3>
<p>In this module's lab, you can use the command <code>time</code> at the terminal to get CPU time. For example, if we want to know how much CPU time it takes to run a matrix multiplication program, we type at the command line:</p>
<pre>
$ time ./matmul 1000
real    0m2.341s
user    0m2.312s
sys     0m0.024s
</pre>
<p>Each line of the output means something specific:</p>
<ul>
<li><b><code>real</code></b> &mdash; The total <b>wall-clock time</b>: how long the program took from start to finish, including time spent waiting for I/O and time when other processes were using the CPU.</li>
<li><b><code>user</code></b> &mdash; The <b>CPU time</b> spent executing your program's own code (user mode). This is the time the CPU was actually doing work for your process.</li>
<li><b><code>sys</code></b> &mdash; The <b>CPU time</b> spent in the kernel on behalf of your program (system mode) &mdash; things like file I/O, memory allocation, and other operating system services.</li>
</ul>
<p>The sum of <code>user</code> + <code>sys</code> gives the total CPU time. For <b>CPU-bound programs</b> (programs that spend most of their time computing), you will see <code>user</code> &asymp; <code>real</code>, because the program is actively using the CPU almost the entire time. For <b>I/O-bound programs</b> (programs that spend a lot of time waiting for disk or network), you will see <code>real</code> >> <code>user</code>, because the program is idle while waiting for data.</p>
<p>Note that <code>real</code> can also be <b>less</b> than <code>user + sys</code> if the program uses multiple CPU cores, since wall-clock time measures elapsed time but CPU time is summed across all cores.</p>
<p>The <code>time</code> command is very useful for getting an overall feel for how fast your program is running, but its downside is that it doesn't say <b>where</b> in the code any slowdowns are. For that, we need a profiler.</p>

<h3>Profiling with gprof</h3>
<p>A <b>profiler</b> is a tool that measures how much time is spent in each function of your program. The profiler we will use is <code>gprof</code>, which is available on the PCC Linux system. Here is the workflow:</p>
<pre>
gcc -pg -O2 -o program program.c    # compile with profiling enabled (-pg flag)
./program                            # run the program (generates gmon.out)
gprof program gmon.out               # print the profile report
</pre>
<p>The <code>-pg</code> flag tells <code>gcc</code> to insert profiling instrumentation into the compiled code. When you run the program, it writes profiling data to a file called <code>gmon.out</code>. Then <code>gprof</code> reads that file and produces a human-readable report.</p>

<h3>Reading a Flat Profile</h3>
<p>The most useful part of <code>gprof</code>'s output is the <b>flat profile</b>, which lists each function and how much time was spent in it. Here is an example of what it might look like:</p>
<pre>
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 78.23      1.83     1.83        1  1830.00  1830.00  multiply_matrices
 12.41      2.12     0.29   100000     0.00     0.00  compute_element
  5.13      2.24     0.12        1   120.00   120.00  initialize_matrix
  2.14      2.29     0.05        1    50.00    50.00  read_input
  2.09      2.34     0.05        1    50.00    50.00  print_result
</pre>
<p>The columns you should focus on are:</p>
<ul>
<li><b>% time:</b> The percentage of total runtime spent in this function. This is the most important column.</li>
<li><b>self seconds:</b> The actual number of seconds spent in this function (not counting functions it calls).</li>
<li><b>calls:</b> How many times this function was called.</li>
</ul>
<p>In this example, <code>multiply_matrices</code> takes <b>78%</b> of the runtime while <code>print_result</code> takes only <b>2%</b>. This tells you exactly where to focus your optimization effort. By Amdahl's Law (from Lesson 4), even if you made <code>print_result</code> infinitely fast, the overall speedup would be negligible. But making <code>multiply_matrices</code> even 2x faster would give a significant overall improvement.</p>

<h3>CPE: Cycles Per Element</h3>
<p>The textbook uses a metric called <b>CPE (Cycles Per Element)</b> to measure the efficiency of code that processes arrays or vectors. CPE is defined as:</p>
<pre>
CPE = (total CPU cycles) / (number of elements processed)
</pre>
<p>A lower CPE means better performance. The advantage of CPE as a metric is that it is <b>independent of the array size</b>: whether you process 1,000 elements or 1,000,000 elements, a well-optimized function should have roughly the same CPE. This makes it useful for comparing different implementations of the same algorithm without worrying about input size.</p>
<p>For example, if a function takes 4,000 cycles to process an array of 1,000 integers, its CPE is 4.0. If you optimize the function to take 2,000 cycles for the same array, the CPE drops to 2.0 &mdash; a 2x improvement. The textbook's optimization chapters use CPE extensively to track progress through successive improvements to a running example.</p>

<h3>Benchmarking Tips</h3>
<p>Getting reliable performance measurements requires some care. Here are some practical tips:</p>
<ul>
<li><b>Run the program multiple times and take the minimum.</b> The minimum runtime is closest to the program's true performance. Higher values include noise from OS scheduling, other processes, and interrupts.</li>
<li><b>Use large enough inputs.</b> The runtime should be at least a few seconds. Very short runtimes are dominated by startup overhead and measurement noise.</li>
<li><b>Be aware of cold caches.</b> The first run of a program (or the first run after changing the input) may be slower because the caches are empty. If you are comparing two implementations, run each one a few times to "warm up" the caches before recording the measurement.</li>
<li><b>Disable CPU frequency scaling if possible.</b> Modern CPUs can change their clock speed dynamically (turbo boost, power saving modes). This can cause inconsistent measurements. On Linux, you can set the CPU governor to "performance" mode if you have the right permissions.</li>
<li><b>Minimize background activity.</b> Close other programs and avoid running benchmarks while the system is under load from other tasks.</li>
</ul>

<h3>Other Useful Tools</h3>
<p>Beyond <code>time</code> and <code>gprof</code>, there are other performance tools worth knowing about:</p>
<ul>
<li><b><code>perf stat</code></b> &mdash; A Linux tool that gives you access to hardware performance counters. It can report the number of cache misses, branch mispredictions, instructions per cycle, and other low-level metrics. Very useful for understanding <b>why</b> a program is slow, not just where.</li>
<li><b><code>valgrind --tool=callgrind</code></b> &mdash; A tool that simulates a cache and records detailed information about function calls and cache behavior. The output can be visualized with <b><code>kcachegrind</code></b>, which shows call graphs and per-line cache miss counts.</li>
<li><b><code>valgrind --tool=cachegrind</code></b> &mdash; Similar to callgrind but focused specifically on cache simulation. It reports the number of cache hits and misses for each line of source code, which is invaluable when optimizing cache behavior (as discussed in Lesson 8).</li>
</ul>
<p>You do not need to master all of these tools for this course, but knowing they exist is valuable. In the lab, we will focus on <code>time</code> and <code>gprof</code>.</p>
</div>
<div class="col-sm-10 offset-sm-1"><footer>End of Lesson 6: How to Measure Performance</footer></div>
</div>
</div></body></html>